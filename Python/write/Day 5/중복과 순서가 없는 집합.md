# 중복과 순서가 없는 집합

* 집합을 사용할 때 : 중괄호 {} 를 이용하여 바로 선언 및 초기화하여 생성할 수 있다.
  * s1 = {3, 2, 5, 1, 8, 4, 3}
  * print(s1, type(s1))
* 이미 존재하는 다른 묶음 자료형을 집합으로 변경할 수 있다.
  * set(묶음 자료형)
    * 요소의 순서가 없다.
    * 중복되는 값은 한 개만 저장한다.
    * 딕셔너리는 key만 저장한다.
  * 묶음 자료형 : 전달 인자로 문자열, 리스트, 딕셔너리, 튜플등을 입력하면 그 값들의 집합으로 변경된다.
  * 집합에는 순서와 중복이 없다.
  * 집합은 리스트 혹은 튜플에 속한 요소의 중복을 제거하기 위한 필터로 사용
  * 인덱싱과 슬라이싱을 사용할 수 없다.
    * 사용하고 싶으면 리스트 혹은 튜플로 변환해야한다.
  * set() : 다른 자료형을 집합으로 변환
  * list() : 다른 자료형을 리스트로 변환
  * tuple() : 다른 자료형을 튜플로 변환
* 집합과 사용할 수 있는 함수

![집합 함수](D:\Computer_Science\Study\Python\Django_Python\Python\write\Day 5\집합 함수.png)

사진 주소 : 

* 집합의 요소를 다루는 다양한 함수

  ![집합 요소와 다양한 함수](D:\Computer_Science\Study\Python\Django_Python\Python\write\Day 5\집합 요소와 다양한 함수.png)

* * 튜플은 한개의 원소로 사용할 수 있지만 리스트와 집합 자체는 집합의 원소로 사용할 수 없다.
  * update는 여러 값으로 인지해 각각 한 개의 원소로 저장한다.
  * add는 입력된 값을 한 개의 원소로 저장한다.



# 반복문

* while문
  * 조건이 참인 동안에 while 범위 안에 있는 코드를 반복
  * 범위 안에 포함된 내용을 반복해서 실행하는 기능
  * 조건문 아래 들여쓰기(tab) 코드
  * while 조건식 :
    * 조건식이 True일 때 종속된 코드 반복 실행
    * 무한 루프가 실행되었을 때 ctrl + c를 눌러 빠져나오기
* for문
  * 주어진 조건이 True일 때 포함된 내용을 반복하는 문법
  * for 변수 in range() :
    * range() 함수를 사용할 때 범위 내 변화 간격은 생략 가능
    * 생략하면 변화 간격으로 1로 자동 설정
    * for 변수 in range() : 를 사용할 때 리스트를 바로 for의 범위로 사용하면 in 다음에 리스트가 바로 오지만
    * 숫자로 범위를 지정하면 range(숫자)로 작성해야한다. 
* for문은 정해진 횟수나 인덱스에 접근할 때, while문은 특정 조건을 만족할 때 반복을 멈추는 흐름에서 많이 쓰인다.
* for문에서 집합 자료형의 요소에 접근할 때는
  * for in 값의 집합자료형 :
  * print()함수 안에서 end = ' '를 작성하면 end 키워드인 공백을 삽입한 뒤 데이터를 이어서 출력한다.
  * end = ',' 를 이용하여 한 줄에 표현할 수 있다.
  * 데이터를 한 줄에 표현하고자 한다면 end 용법을 사용한다.
  * 조건식의 변수를 여러 개 사용 가능하다.
  * 딕셔너리에 사용할 때는 Items라는 객체로 접근해야 한다.



# 조건문과 제어문

* 조건문
  * if문, elif문, else문
    * ex) if num == 4 :
  * 따옴표 혹은 괄호 안에 공백이거나 숫자 0이 입력되어 있으면 false로 처리한다.
    * if "" :   if 0 :     => false
    * if " " :  if 1 :     => true
* 비교 연산자
  * and, or, not
* 요소 in
  * in 키워드를 통해 리스트, 튜플, 문자열에 요소가 있으면 True, 없으면 False
  * not in : 요소가 존재할 때 False, 존재하지 않으면 True

* 제어문
  * break, continue



# 함수

* 함수의 대표 역할
  * 지정 기능을 실행하는 단위
  * 코드의 가독성과 프로그램의 효율성 증대
* <u>함수 정의</u> : 특정 기능을 위해 만든 여러 문장을 묶어서 실행하는 코드 블록 단위
* def 함수 이름 (매개변수 1, 매개변수 2, ...) :
  * 실행 구문
  * ~
  * return 반환 값
* 함수 호출
  * 함수 이름(전달인자1, 전달인자2, ...)
* def : 함수를 정의하는 키워드
  * ex) def inputnums() :
  *    a = 0; b = 0
  *  return a, b
  * n1, n2 = inputnums() // 반환 값이 두 개이니 두 변수에 초기화

## 매우 중요함(함수에서 처음 알게 된 부분)

* 함수에서 전역변수를 사용할 때

  * 함수안에서 전역변수 사용 알림으로 global 전역변수를 입력한다.

  * ex)

  * sum = 0

    def myfunc():

      global sum

      for num in range(0,5):

    ​    value = int(input())

    ​    sum += value

      print(sum)

    

    myfunc()



# 매개변수

* 가변 인자 함수 
  * 동일한 기능을 수행하지만 매개변수만 다른 함수
  * def 함수 이름(*매개변수)
  * 가변 인자는 튜플 형식으로 저장된다.
  * 함수에서 매개변수는 가변 인자와 일반 매개변수를 같이 사용할 수 있다.
  * 일반 매개변수는 가변 인자 앞에 입력해서 사용한다.
* 키워드 매개변수
  * 함수 매개변수 앞에 **를 입력하면 함수를 호출할 때 전달 인자를
  * key1 = value1, key2 = value2, key3 = value3 형식으로 입력해 딕셔너리 형태로 선언할 수 있다.
  * 출력시 key:value 값으로 분류된다.
  * key는 따옴표로 감싸지 않고 변수처럼 입력하여 사용해야 한다.
    * key에는 숫자 및 따옴표로 감싼 문자열은 입력할 수 없다. (변수처럼 입력하여 사용)
    * key는 값 자체 문자열로 저장, value는 변수, 숫자 가능
      * ex) func(1, 3, 5, 7, apple = "사과", a = num, num = 4)
      * def func (*nums, **kwargs) :
        * nums : 1, 3, 5, 7
        * kwargs : apple = "사과", a = num, num = 4
  * 순서 : 가변인자, 키워드 매개변수 (이 두개 순서 바꿀 수 없다.)
* 반환 값
  * 파이썬은 매개변수 이름만 입력하면 어떤 자료형을 입력하든 그대로 전달하는 편리함을 가지고 있다.
  * 반환 값 자체를 함수에 명시하지 않고 return 뒤에 반환할 값을 입력만 하면 된다.
  * 최소한 반환 값에 맞게 함수를 호출하면서 같은 개수의 변수를 할당해야 규칙
  * 반환 값들이 여러 개일 경우, 하나의 리스트나 튜플로 묶어 하나의 변수로 반환해준다.
  * 파이썬은 반환 값이 여러 개일때 자동으로 튜플로 반환한다.
  * return : 함수를 종료함과 동시에 값을 반환하는 키워드



# 전역변수와 지역변수

* 전역변수 : 코드 전체에서 사용할 수 있는 변수
  * 어디서든 참조가 가능하다.
  * 함수안에서 전역변수에 새로운 값을 '대입'하는 것은 불가능하다.



* * 전역변수 단점

    * 메모리를 비효율적으로 사용할 수 있다.
    * 값에 쉽게 접근할 수 있는 만큼 코드의 흐름을 파악하는데 방해될 수 있다.
    * 보통 전역변수는 변하지 않고 여러 기능에서 참조해야 하는 값으로 사용한다.

  * 전역변수 수정

    * global
      * 불가피하게 전역변수를 수정해야 하는 일이 발생한다면 global 키워드를 사용한다.

    ![global](D:\Computer_Science\Study\Python\Django_Python\Python\write\Day 5\global.png)

    * ex) def plusNum(n) :
          return n + num

      num = 3
      print(plusNum(17))

    * 결과 : 2

    * num을 수정한대로 변경된다.

    * global은 외부와 소통하는 흐름을 깨기 때문에 반환 값을 이용하여 전역 변수를 수정하는 것을 추천한다.

    * ex) num = 1 #전역변수 선언 

      def plusNum(a) : 

      a += 1 

      print(a)  

      return a 

      num = plusNum(num) 

      print(num)

      * 함수의 실행 결과를 누적, 가급적이면 global를 사용하지 않도록 한다.

* 지역변수 : 정해진 범위에서만 사용 가능한 변수

  * ex)  def plusNum(n) :
        return n + num

    num = 3
    print(plusNum(17))

  * num : 전역변수, n : 지역변수

